<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
	<HEAD>
		<TITLE></TITLE>
		<META NAME="Generator" CONTENT="pdf_to_html">
	</HEAD>
<BODY
	BGCOLOR="#FFFFFF"
	TEXT="#000000"
	LINK="#0000FF"
	VLINK="#808000"
	ALINK="#FF00FF"
>
<H1><FONT FACE="Verdana, Arial" COLOR="#0050B2">NAME

</FONT></H1>
<P><FONT FACE="Verdana, Arial" SIZE="3">PDF::API2::PDF::Objind - PDF indirect object reference. Also acts as an abstract
superclass for all elements in a PDF file.

</FONT></P>
<H1><FONT FACE="Verdana, Arial" COLOR="#0050B2">INSTANCE VARIABLES

</FONT></H1>
<P><FONT FACE="Verdana, Arial" SIZE="3">Instance variables differ from content variables in that they all start with
a space.

</FONT></P>
<TABLE CELLSPACING="0" CELLPADDING="0" BORDER="0"><TR><TD>
</TD></TR><TR><TD> &nbsp; &nbsp; &nbsp; &nbsp; </TD></TR><TR><TD COLSPAN="2"><FONT FACE="Verdana, Arial" COLOR="#B25000" SIZE="3"><B>parent

</B></FONT></TD></TR><TR><TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>
<P><FONT FACE="Verdana, Arial" SIZE="3">For an object which is a reference to an object in some source, this holds the
reference to the source object, so that should the reference have to be
de-referenced, then we know where to go and get the info.

</FONT></P>
</TD></TR><TR><TD> &nbsp; &nbsp; &nbsp; &nbsp; </TD></TR><TR><TD COLSPAN="2"><FONT FACE="Verdana, Arial" COLOR="#B25000" SIZE="3"><B>objnum (R)

</B></FONT></TD></TR><TR><TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>
<P><FONT FACE="Verdana, Arial" SIZE="3">The object number in the source (only for object references)

</FONT></P>
</TD></TR><TR><TD> &nbsp; &nbsp; &nbsp; &nbsp; </TD></TR><TR><TD COLSPAN="2"><FONT FACE="Verdana, Arial" COLOR="#B25000" SIZE="3"><B>objgen (R)

</B></FONT></TD></TR><TR><TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>
<P><FONT FACE="Verdana, Arial" SIZE="3">The object generation in the source

</FONT></P>
<P><FONT FACE="Verdana, Arial" SIZE="3">There are other instance variables which are used by the parent for file control.

</FONT></P>
</TD></TR><TR><TD> &nbsp; &nbsp; &nbsp; &nbsp; </TD></TR><TR><TD COLSPAN="2"><FONT FACE="Verdana, Arial" COLOR="#B25000" SIZE="3"><B>isfree

</B></FONT></TD></TR><TR><TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>
<P><FONT FACE="Verdana, Arial" SIZE="3">This marks whether the object is in the free list and available for re-use as
another object elsewhere in the file.

</FONT></P>
</TD></TR><TR><TD> &nbsp; &nbsp; &nbsp; &nbsp; </TD></TR><TR><TD COLSPAN="2"><FONT FACE="Verdana, Arial" COLOR="#B25000" SIZE="3"><B>nextfree

</B></FONT></TD></TR><TR><TD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD>
<P><FONT FACE="Verdana, Arial" SIZE="3">Holds a direct reference to the next free object in the free list.

</FONT></P>
</TD></TR></TABLE>
<H1><FONT FACE="Verdana, Arial" COLOR="#0050B2">METHODS

</FONT></H1>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">PDF::API2::PDF::Objind->new()

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Creates a new indirect object

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">uid

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Returns a Unique id for this object, creating one if it didn't have one before

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->release

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Releases ALL of the memory used by this indirect object, and all of its
component/child objects.  This method is called automatically by
'<CODE>PDF::API2::PDF::File-&gt;release</CODE>' (so you don't have to call it yourself).

</FONT></P>
<P><FONT FACE="Verdana, Arial" SIZE="3"><B>NOTE</B>, that it is important that this method get called at some point prior
to the actual destruction of the object.  Internally, PDF files have an
enormous amount of cross-references and this causes circular references within
our own internal data structures.  Calling '<CODE>release()</CODE>' forces these circular
references to be cleaned up and the entire internal data structure purged.

</FONT></P>
<P><FONT FACE="Verdana, Arial" SIZE="3"><B>Developer note:</B> As part of the brute-force cleanup done here, this method
will throw a warning message whenever unexpected key values are found within
the <CODE>PDF::API2::PDF::Objind</CODE> object.  This is done to help ensure that unexpected
and unfreed values are brought to your attention, so you can bug us to keep the
module updated properly; otherwise the potential for memory leaks due to
dangling circular references will exist.

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->val

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Returns the val of this object or reads the object and then returns its value.

</FONT></P>
<P><FONT FACE="Verdana, Arial" SIZE="3">Note that all direct subclasses *must* make their own versions of this subroutine
otherwise we could be in for a very deep loop!

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->realise

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Makes sure that the object is fully read in, etc.

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->outobjdeep($fh, $pdf)

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">If you really want to output this object, then you must need to read it first.
This also means that all direct subclasses must subclass this method or loop forever!

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->outobj($fh)

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">If this is a full object then outputs a reference to the object, otherwise calls
outobjdeep to output the contents of the object at this point.

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->elementsof

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Abstract superclass function filler. Returns self here but should return
something more useful if an array.

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->empty

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Empties all content from this object to free up memory or to be read to pass
the object into the free list. Simplistically undefs all instance variables
other than object number and generation.

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->merge($objind)

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">This merges content information into an object reference place-holder.
This occurs when an object reference is read before the object definition
and the information in the read data needs to be merged into the object
place-holder

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->is_obj($pdf)

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Returns whether this object is a full object with its own object number or
whether it is purely a sub-object. $pdf indicates which output file we are
concerned that the object is an object in.

</FONT></P>
<H2><FONT FACE="Verdana, Arial" COLOR="#0050B2">$r->copy($pdf, $res)

</FONT></H2>
<P><FONT FACE="Verdana, Arial" SIZE="3">Returns a new copy of this object. The object is assumed to be some kind
of associative array and the copy is a deep copy for elements which are
not PDF objects, according to $pdf, and shallow copy for those that are.
Notice that calling <CODE>copy</CODE> on an object forces at least a one level
copy even if it is a PDF object. The returned object loses its PDF
object status though.

</FONT></P>
<P><FONT FACE="Verdana, Arial" SIZE="3">If $res is defined then the copy goes into that object rather than creating a
new one. It is up to the caller to bless $res, etc. Notice that elements from
$self are not copied into $res if there is already an entry for them existing
in $res.

</FONT></P>
</BODY>
</HTML>
